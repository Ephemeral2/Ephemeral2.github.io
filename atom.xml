<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ephemeral</title>
  
  <subtitle>Live Fast, Die Young, Be Wild, Have Fun</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-30T04:33:12.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Ephemeral</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Neutral Network</title>
    <link href="http://example.com/2022/03/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C+%E5%85%A8%E8%BF%9E%E6%8E%A5+Tahn+Relu/"/>
    <id>http://example.com/2022/03/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C+%E5%85%A8%E8%BF%9E%E6%8E%A5+Tahn+Relu/</id>
    <published>2022-03-29T16:00:00.000Z</published>
    <updated>2022-03-30T04:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h1><h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>​神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为<strong>权重（weight）</strong>。不同的权重和激活函数，则会导致神经网络不同的输出。</p><p>​举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。从而识别当前数字是什么字。$$\omega*X+b$$</p><p><img src="https://img-blog.csdn.net/20160716131107406" alt="img"></p><p>基本 $wx + b$ 的形式，其中</p><ul><li>$x1,x2$  表示输入向量</li><li>$w1,w2$  为权重，几个输入则意味着有几个权重，即每个输入都被赋予一个权重</li><li><em>b</em>为偏置bias</li><li>$g(z)$ 为激活函数</li><li><em>a</em> 为输出</li></ul><p>​一开始为了简单，人们把激活函数定义成一个线性函数，即对于结果做一个线性变化，比如一个简单的线性激活函数是g(z) &#x3D; z，输出都是输入的线性变换。后来实际应用中发现，线性激活函数太过局限，于是人们引入了非线性激活函数。</p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>​将上文的神经元结合在一起便组成了神经网络，下图是一个三层神经网络。</p><p>​输入层(样本数据)<br>​隐藏层(隐藏层的层数和每层的神经元数目需要自己给定)， 如果有多个隐藏层，则意味着多个激活函数。<br>​输出层(预测目标)</p><img src="https://img-blog.csdnimg.cn/20190101123204625.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTcyMzQ2NA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><p>​同时，每一层都可能由单个或多个神经元组成，每一层的输出将会作为下一层的输入数据。比如下图中间隐藏层来说，隐藏层的3个神经元a1、a2、a3皆各自接受来自多个不同权重的输入（因为有x1、x2、x3这三个输入，所以a1 a2 a3都会接受x1 x2 x3各自分别赋予的权重，即几个输入则几个权重），接着，a1、a2、a3又在自身各自不同权重的影响下 成为的输出层的输入，最终由输出层输出最终结果。<img src="https://img-blog.csdn.net/20160703110336151" alt="img"></p><p>​$a_i^j$ 表示第j层第i个单元的激活函数&#x2F;神经元</p><p>​$\Theta^{(j)}$ 表示从第j层映射到第j+1层的控制函数的权重矩阵 </p><p>​此外，输入层和隐藏层都存在一个偏置（bias unit)，所以上图中也增加了偏置项：x0、a0。针对上图，有如下公式<br>$$<br>a_1^{(2)} &#x3D; g(\Theta_{10}^{(1)}x_0+\Theta_{11}^{(1)}x_1+\Theta_{12}^{(1)}x_2+\Theta_{13}^{(1)}x_3)\a_2^{(2)} &#x3D; g(\Theta_{20}^{(1)}x_0+\Theta_{21}^{(1)}x_1+\Theta_{22}^{(1)}x_2+\Theta_{23}^{(1)}x_3)\a_3^{(2)} &#x3D; g(\Theta_{30}^{(1)}x_0+\Theta_{31}^{(1)}x_1+\Theta_{32}^{(1)}x_2+\Theta_{33}^{(1)}x_3)\h_{\Theta}(x) &#x3D; a_1^{(3)} &#x3D; g(\Theta_{10}^{(2)}a_0^{(2)}+\Theta_{11}^{(2)}a_1^{(2)}+\Theta_{12}^{(2)}a_2^{(2)}+\Theta_{13}^{(2)}a_3^{(2)})<br>$$</p><h3 id="卷积神经网络的层级结构"><a href="#卷积神经网络的层级结构" class="headerlink" title="卷积神经网络的层级结构"></a>卷积神经网络的层级结构</h3><p><img src="https://img-blog.csdn.net/20160702205047459" alt="img"></p><p>最左边是：</p><p>​数据输入层，在该层对数据做一些处理，比如去均值（把输入数据各个维度都中心化为0，避免数据过多偏差，影响训练效果）、归一化（把所有的数据都归一到同样的范围）、PCA&#x2F;白化等等。CNN只对训练集做“去均值”这一步。</p><p>中间是：</p><p>​CONV：卷积计算层，线性乘积 求和。<br>​RELU：激励层<br>​POOL：池化层，简言之，即取区域平均或最大。</p><p>最右边是：</p><p>​FC：全连接层</p><h3 id="CNN的卷积计算层"><a href="#CNN的卷积计算层" class="headerlink" title="CNN的卷积计算层"></a>CNN的卷积计算层</h3><h4 id="卷积："><a href="#卷积：" class="headerlink" title="卷积："></a>卷积：</h4><p>​对不同的数据窗口数据和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做<strong>内积</strong>（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源。</p><p>​如下图中，图中左边部分是原始输入数据，图中中间部分是滤波器filter，图中右边是输出的新的二维数据</p><p><img src="https://img-blog.csdn.net/20160702215705128" alt="img"></p><p>$4<em>0 + 0</em>0 + 0<em>0 + 0</em>0 + 0<em>1 + 0</em>1 + 0<em>0 + 0</em>1 + -4*2 &#x3D; -8$</p><p>​在CNN中，滤波器filter（带着一组固定权重的神经元）对局部输入数据进行卷积计算。每计算完一个数据窗口内的局部数据后，数据窗口不断平移滑动，直到计算完所有数据。这个过程中，有这么几个参数：<br>　　a. 深度depth：神经元个数，决定输出的depth厚度。同时代表滤波器个数。</p><p>​b. 步长stride：决定滑动多少步可以到边缘。</p><p>​　c. 填充值zero-padding：在外围边缘补充若干圈0，方便从初始位置以步长为单位可以刚好滑倒末尾位置，通俗地讲就是为了总长能被步长整除。 </p><p><img src="https://img-blog.csdn.net/20160705162205761" alt="img"></p><p><img src="https://img-blog.csdn.net/20160707204048899" alt="img"></p><h4 id="激励层与池化层"><a href="#激励层与池化层" class="headerlink" title="激励层与池化层"></a>激励层与池化层</h4><h5 id="激励："><a href="#激励：" class="headerlink" title="激励："></a>激励：</h5><p>实际梯度下降中，sigmoid容易饱和、造成终止梯度传递，且没有0中心化。因此可以尝试另外一个激活函数：ReLU 优点是收敛快，求梯度简单。</p><h5 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h5><p>​下图所展示的是取区域最大，即上图左边部分中 左上角2x2的矩阵中6最大，右上角2x2的矩阵中8最大，左下角2x2的矩阵中3最大，右下角2x2的矩阵中4最大，所以得到上图右边部分的结果：6 8 3 4。<img src="https://img-blog.csdn.net/20160703121026432" alt="img"></p><h2 id="非线性函数-激活函数"><a href="#非线性函数-激活函数" class="headerlink" title="非线性函数(激活函数)"></a>非线性函数(激活函数)</h2><p>​如果把神经元的非线性函数去掉的话，那么这个神经元可以写成：<strong>输出&#x3D;输入*权值+偏置</strong>。这个就是<em>线性回归方程</em>，所以如果把神经网络的非线性函数去掉，那么<em>整个网络就是由多个线性回归</em>组成的。线性回归是线性方程，只能解决线性可分的问题。多个线性回归组成的结果无论经过多少的层的神经网络，其本质上也是线性方程。但现实中的很多需要解决的问题都是线性不可分的(异或问题)。*<em>所以为了解决这些线性不可分的问题，我们引入了非线性方程 g</em>，那么输出就变为了 $$g(\omega*X+b)$$。</p><h3 id="目前常用的非线性函数"><a href="#目前常用的非线性函数" class="headerlink" title="目前常用的非线性函数"></a>目前常用的非线性函数</h3><h4 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数:"></a>sigmoid函数:</h4><p>$$<br>S(x) &#x3D; \frac{1}{1+e^{-x}}<br>$$</p><p><img src="https://img-blog.csdnimg.cn/20190101125917773.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTcyMzQ2NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​sigmoid函数把求和的结果都变为(0,1)之间的值，压缩至0到1有何用处呢？用处是这样一来便可以把激活函数看作一种“分类的概率”，比如激活函数的输出为0.9的话便可以解释为90%的概率为正样本。</p><h4 id="tanh函数："><a href="#tanh函数：" class="headerlink" title="tanh函数："></a>tanh函数：</h4><p>$$<br>tanh(x) &#x3D; \frac{sinh(x)}{cosh(x)}&#x3D;\frac{e^x-e^{-x}}{e^x+e^{-x}}<br>$$</p><p><img src="https://img-blog.csdnimg.cn/2019010113063249.png" alt="img"></p><p>​在具体应用中，tanh函数相比于Sigmoid函数往往更具有优越性，这主要是因为<strong>Sigmoid函数在输入处于[-1,1]之间时，函数值变化敏感</strong>，一旦接近或者超出区间就失去敏感性，处于饱和状态，影响神经网络预测的精度值。主要体现在计算梯度时。</p><h4 id="relu函数："><a href="#relu函数：" class="headerlink" title="relu函数："></a>relu函数：</h4><p>$$<br>f(x) &#x3D; max(0,x)<br>$$</p><p><img src="https://img-blog.csdnimg.cn/20190101131458349.png" alt="img"></p><p>​relu函数并未像tanh函数和sigmoid函数一样，将求和的值限制在(0,1)之间。其阈值是[0,+∞]。</p><p>​上面3个激活函数主要是用在从输入层到隐藏层以及隐藏层到隐藏层之间。</p><p>​对于最后一层隐藏层到输出层之间，一般选用softmax函数进行归一化。</p><h4 id="softmax函数："><a href="#softmax函数：" class="headerlink" title="softmax函数："></a>softmax函数：</h4><p>$$<br>\sigma(z)<em>j &#x3D; \frac{e^{z_j}}{\sum</em>{k&#x3D;1}^Ke^{z_k}}\\for j &#x3D; 1,…,K<br>$$</p><p>​由于在用神经网络解决的问题大部分都是多分类问题，softmax是将多分类转化为概率的一个函数。如果预测的目标是二分类，则使用sigmoid进行二分类的概率转化。</p><p>上面表达式中的 $z^j$ &#x3D; 隐藏层的输入<em>权重+偏置，</em>K*为预测目标的分类数量。</p><h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><p>​全连接层（fully connected layers，FC）在整个卷积神经网络中起到“分类器”的作用。</p><p>​全连接层每一个结点都与上一层的所有结点相连，用来把前边提取到的特征综合起来。由于其全相连的特性，一般全连接层的参数也是最多的。</p><p>​<img src="https://img-blog.csdnimg.cn/20190325192219666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTk3OTIw,size_16,color_FFFFFF,t_70" alt="img"></p><p>​从左至右，一张彩色图片输入到网络，白色框是卷积层，红色是池化，蓝色是全连接层，棕色框是预测层。预测层的作用是将全连接层输出的信息转化为相应的类别概率，而起到分类作用。</p><p>​如果说卷积层、池化层和激活函数层（预测层）等操作是将原始数据映射到隐层特征空间的话，全连接层则起到将学到的“分布式特征表示<strong>（7x7x512）</strong>”映射到样本标记空间**(三个全连接层)**的作用。在实际使用中，全连接层可由卷积操作实现：</p><p>​对前层是全连接的全连接层可以转化为卷积核为1x1的卷积；而前层是卷积层的全连接层可以转化为卷积核为$h*w$的全局卷积，h和w分别为前层卷积结果的高和宽<strong>（7x7）</strong>。</p><p>​全连接的核心操作就是矩阵向量乘积 $ y &#x3D; Wx$</p><p>​本质就是由一个特征空间线性变换到另一个特征空间。目标空间的任一维 (也就是隐层的一个 cell)都认为会受到源空间的每一维的影响。不考虑严谨，可以说，<strong>目标向量是源向量的加权和</strong>。</p><p>​在 CNN 中，全连接常出现在最后几层，用于对前面设计的特征做加权和。比如 mnist，前面的卷积和池化相当于做特征工程，后面的全连接相当于做特征加权。<u>在 RNN 中，全连接用来把 embedding 空间拉到隐层空间，把隐层空间转回 label 空间等</u>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/qq_41997920/article/details/88803736?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_default&amp;utm_relevant_index=5">https://blog.csdn.net/qq_41997920/article/details/88803736?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_default&amp;utm_relevant_index=5</a></p><p><a href="https://y1ran.blog.csdn.net/article/details/81385159?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.topblog&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3.topblog&amp;utm_relevant_index=6">https://y1ran.blog.csdn.net/article/details/81385159?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.topblog&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.topblog&amp;utm_relevant_index=6</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/51812459?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164860614516782089398149%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164860614516782089398149&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51812459.142">https://blog.csdn.net/v_JULY_v/article/details/51812459?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164860614516782089398149%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164860614516782089398149&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51812459.142</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人工神经网络&quot;&gt;&lt;a href=&quot;#人工神经网络&quot; class=&quot;headerlink&quot; title=&quot;人工神经网络&quot;&gt;&lt;/a&gt;人工神经网络&lt;/h1&gt;&lt;h2 id=&quot;神经元&quot;&gt;&lt;a href=&quot;#神经元&quot; class=&quot;headerlink&quot; title=&quot;神经元</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo博客部署</title>
    <link href="http://example.com/2022/03/29/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2022/03/29/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2/</id>
    <published>2022-03-29T15:10:55.000Z</published>
    <updated>2022-03-30T02:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用HEXO实现个人博客"><a href="#使用HEXO实现个人博客" class="headerlink" title="使用HEXO实现个人博客"></a>使用HEXO实现个人博客</h1><p>Node.js 安装<br>npm -v<br>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>cnpm install -g hexo-cli<br>hexo -v<br>C:\Users\21059165g&gt;mkdir My_Blog<br>hexo init<br>hexo s<br><a href="http://localhost:4000/">http://localhost:4000/</a><br>hexo n “post_name”<br>也可以创建md文件再复制到文件夹下<br>cd source&#x2F;_posts</p><h2 id="将个人博客推到github"><a href="#将个人博客推到github" class="headerlink" title="将个人博客推到github"></a>将个人博客推到github</h2><p>C:\Users\21059165g\My_Blog&gt;cnpm install –save hexo-deployer-git<br>打开 _config.yml<br>deploy:<br>  type: git<br>  repo: <a href="https://github.com/HANE-iwnl/HANE-iwnl/_posts.github.io.git">https://github.com/HANE-iwnl/HANE-iwnl/_posts.github.io.git</a><br>  branch :master<br>hexo d</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes&#x2F;yilia</p><p>Hexo clean<br>Hexo g<br>Hexo s</p><h2 id="使hexo支持数学公式"><a href="#使hexo支持数学公式" class="headerlink" title="使hexo支持数学公式"></a>使hexo支持数学公式</h2><p>npm install hexo-math –save</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-emoji</span><br><span class="line">    - hexo-math</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br><span class="line"># Han Support docs: https://hanzi.pro/</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: A Title</span><br><span class="line">date: 2020-02-08 10:39:55</span><br><span class="line">tags:</span><br><span class="line">- tag1</span><br><span class="line">- tag2</span><br><span class="line">categories:</span><br><span class="line">- parent</span><br><span class="line">- child</span><br><span class="line"></span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用HEXO实现个人博客&quot;&gt;&lt;a href=&quot;#使用HEXO实现个人博客&quot; class=&quot;headerlink&quot; title=&quot;使用HEXO实现个人博客&quot;&gt;&lt;/a&gt;使用HEXO实现个人博客&lt;/h1&gt;&lt;p&gt;Node.js 安装&lt;br&gt;npm -v&lt;br&gt;npm in</summary>
      
    
    
    
    
  </entry>
  
</feed>
