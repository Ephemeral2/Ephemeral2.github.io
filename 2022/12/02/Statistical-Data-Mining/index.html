<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>statistical data mining | Ephemeral</title><meta name="author" content="Ephemeral"><meta name="copyright" content="Ephemeral"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Intro0.1. Derivatives设向量$X为\begin{pmatrix} X_1\\X_2\\X_3\\…\\X_p \end{pmatrix}\$ 0.2. TaylorChapter 1Chapter 2Chapter 3Chapter 44.1. Singular Value Decomposition4.2. Least Squares4.3. Ridge Regression">
<meta property="og:type" content="article">
<meta property="og:title" content="statistical data mining">
<meta property="og:url" content="http://example.com/2022/12/02/Statistical-Data-Mining/index.html">
<meta property="og:site_name" content="Ephemeral">
<meta property="og:description" content="Intro0.1. Derivatives设向量$X为\begin{pmatrix} X_1\\X_2\\X_3\\…\\X_p \end{pmatrix}\$ 0.2. TaylorChapter 1Chapter 2Chapter 3Chapter 44.1. Singular Value Decomposition4.2. Least Squares4.3. Ridge Regression">
<meta property="og:locale">
<meta property="article:published_time" content="2022-12-02T07:20:21.000Z">
<meta property="article:modified_time" content="2022-12-07T08:40:26.050Z">
<meta property="article:author" content="Ephemeral">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/02/Statistical-Data-Mining/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'statistical data mining',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-07 16:40:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Ephemeral" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ephemeral</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">statistical data mining</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-02T07:20:21.000Z" title="Created 2022-12-02 15:20:21">2022-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-07T08:40:26.050Z" title="Updated 2022-12-07 16:40:26">2022-12-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="statistical data mining"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="0-1-Derivatives"><a href="#0-1-Derivatives" class="headerlink" title="0.1. Derivatives"></a>0.1. Derivatives</h2><p>设向量$X为\begin{pmatrix} X_1\\X_2\\X_3\\…\\X_p \end{pmatrix}\$</p>
<h2 id="0-2-Taylor"><a href="#0-2-Taylor" class="headerlink" title="0.2. Taylor"></a>0.2. Taylor</h2><h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h1 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h1><h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1><h2 id="4-1-Singular-Value-Decomposition"><a href="#4-1-Singular-Value-Decomposition" class="headerlink" title="4.1. Singular Value Decomposition"></a>4.1. Singular Value Decomposition</h2><h2 id="4-2-Least-Squares"><a href="#4-2-Least-Squares" class="headerlink" title="4.2. Least Squares"></a>4.2. Least Squares</h2><h2 id="4-3-Ridge-Regression"><a href="#4-3-Ridge-Regression" class="headerlink" title="4.3. Ridge Regression"></a>4.3. Ridge Regression</h2><h2 id="4-4-Lasso"><a href="#4-4-Lasso" class="headerlink" title="4.4. Lasso"></a>4.4. Lasso</h2><h1 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h1><h2 id="5-1-Classification"><a href="#5-1-Classification" class="headerlink" title="5.1 Classification"></a>5.1 Classification</h2><p><strong>分类（classification）</strong>：分类任务就是通过学习得到一个目标函数$f$（或分类模型），把每个属性集x映射到一个预先定义的类标签（Label）$y$。</p>
<p><strong>建立分类模型的一般方法：</strong></p>
<p><img src="../img/SouthEast.png" alt="SouthEast"></p>
<h2 id="5-2-Decision-Tree"><a href="#5-2-Decision-Tree" class="headerlink" title="5.2 Decision Tree"></a>5.2 Decision Tree</h2><h3 id="5-2-1-结点："><a href="#5-2-1-结点：" class="headerlink" title="5.2.1 结点："></a>5.2.1 结点：</h3><p><strong>决策树中包含三种结点：</strong></p>
<ul>
<li>根结点（root node）: the first criterion. No incoming edge.</li>
<li>内部结点（internal node）: all the other criteria. Only one incoming edge, two or more outgoing edges.</li>
<li>叶结点（leaf node）: one incoming edge and no outgoing edge.</li>
</ul>
<h3 id="5-2-2-Hunt-Algorithm："><a href="#5-2-2-Hunt-Algorithm：" class="headerlink" title="5.2.2 Hunt Algorithm："></a>5.2.2 Hunt Algorithm：</h3><p>通过将训练记录相继划分为纯度较高的子集，以递归的方式建立决策树。</p>
<p>设$D_t$是与结点t相关联的训练集/训练数据，而$y={y_1,y_2,…,y_c}$是类标号，Hunt算法的递归定义如下：</p>
<ul>
<li>如果$D_t$中所有记录都属于同一个类$y_t$，则t是叶结点，用$y_t$标记。</li>
<li>如果$D_t$中包含属于多个类的记录，则选择一个属性，并利用该属性将记录划分为较小的子集。对于测试条件的每个输出，创建一个子结点，并根据测试结果将$D_t$中的记录分布到子结点中。然后，对每个子女结点，递归调用该算法。</li>
</ul>
<p>第二步所创建的子结点可能为空，即不存在与这些结点相关联的记录。该节点成为叶结点，类标号为其父结点上训练记录中的多数类。</p>
<p>在第二步，如果与$D_t$相关联的所有记录都具有相同属性值（目标属性除外），则不可能进一步划分这些记录。这种情况下，该结点为叶结点，其标号为与该结点相关联的训练记录中的多数类。</p>
<h3 id="5-2-3-表示属性测试条件的方法"><a href="#5-2-3-表示属性测试条件的方法" class="headerlink" title="5.2.3 表示属性测试条件的方法"></a>5.2.3 <strong>表示属性测试条件的方法</strong></h3><p><strong>二元属性：</strong>二元属性的测试条件产生两个可能的输出。</p>
<p><strong>标称属性：</strong></p>
<ul>
<li>多路划分（Multi-way split）：其输出数取决于该属性不同属性值的个数。</li>
<li>二元划分（Binary (2-way) split）：某些决策树算法（如CART）只产生二元划分，它们考虑创建k个属性值的二元划分的所有$2^{(k-1)} -1$种方法。</li>
</ul>
<p><strong>序数属性：</strong>序数属性也可以产生二元或多路划分，只要不违背序数属性值的有序性，就可以对属性值进行分组。</p>
<p><strong>连续属性：</strong>to be continued…</p>
<h3 id="5-2-4-选择最佳划分的度量"><a href="#5-2-4-选择最佳划分的度量" class="headerlink" title="5.2.4 选择最佳划分的度量"></a>5.2.4 <strong>选择最佳划分的度量</strong></h3><p>选择最佳划分的度量通常是根据划分后子女结点不纯性的程度。</p>
<h4 id="5-2-4-1-Measures-of-Impurity"><a href="#5-2-4-1-Measures-of-Impurity" class="headerlink" title="5.2.4.1 Measures of Impurity"></a>5.2.4.1 Measures of Impurity</h4><p>​    <img src="../img/v2-e5cddc4aae60bd7a14a8089afb0e5453_1440w.webp" alt="img" style="zoom:50%;" /></p>
<p>​    为了确定测试条件的效果，我们需要比较父结点（划分前）的不纯程度和子结点（划分后）的不纯程度，它们的差越大，测试条件的效果就越好。增益 $Δ $：</p>
<p>​    <img src="../img/v2-dc00c81ccff5b057185c5f07dbc207e8_1440w.webp" alt="img" style="zoom:50%;" />    </p>
<p>决策树算法通常选择最大化增益 $Δ $的测试条件。因为对所有的测试条件来说，$I(parent)$是一样的，所以<strong>最大化增益等价于最小化子结点的不纯性度量的加权平均值</strong>。特别地，当选择熵作为上述增益公式的不纯性度量时，称该增益为<strong>信息增益</strong>。</p>
<h3 id="5-2-5-Model-over-fitting"><a href="#5-2-5-Model-over-fitting" class="headerlink" title="5.2.5 Model over-fitting"></a>5.2.5 Model over-fitting</h3><p>分类模型的误差大致分为两种：训练误差和泛化误差。</p>
<p>拟合不足：训练误差与检验误差都很大</p>
<p>过分拟合：训练误差下降但是检验误差上升</p>
<p><img src="../img/70.png" alt="img" style="zoom:50%;" /></p>
<p>过拟合的原因：</p>
<ol>
<li><p>噪声导致的过拟合：样本被错误标记。</p>
</li>
<li><p>缺乏代表性样本导致的过分拟合：根据少量训练记录做出分类决策的模型也容易受过分拟合的影响。</p>
</li>
</ol>
<h4 id="5-2-5-1-解决过拟合的方式"><a href="#5-2-5-1-解决过拟合的方式" class="headerlink" title="5.2.5.1 解决过拟合的方式"></a>5.2.5.1 解决过拟合的方式</h4><ul>
<li>Pre-pruning:  预剪枝要对划分前后的泛化性能进行估计来决定是否要进行这个划分</li>
<li>Post-pruning:<ul>
<li>分析剪枝前后泛化能力（验证集精度）</li>
<li>奥卡姆剃刀原则：虽然剪枝后精度并未提升，但是模型简化了也需要剪枝。</li>
</ul>
</li>
</ul>
<h4 id="5-2-5-2-ID3-algorithm"><a href="#5-2-5-2-ID3-algorithm" class="headerlink" title="5.2.5.2 ID3 algorithm"></a>5.2.5.2 ID3 algorithm</h4><p>信息增益是特征选择中的一个重要指标，它定义为一个特征能够为分类系统带来多少信息，带来的信息越多，该特征越重要。</p>
<p>基本信息包括：熵，期望信息和信息增益。</p>
<ol>
<li>熵：设D为用类别对训练元组进行的划分，则D的熵表示为：</li>
</ol>
<p><img src="../img/Center.png" alt="img" style="zoom:50%;" /></p>
<p>其中$p_i$表示第i个类别在整个训练元组中出现的概率，可以用属于此类别元素的数量除以训练元组元素总数量作为估计。熵的实际意义表示是D中元组的类标号所需要的平均信息量。</p>
<ol>
<li>期望信息：</li>
</ol>
<p><img src="../img/Center-16704020074006.png" alt="img" style="zoom:50%;" /></p>
<p>现在我们假设将训练元组D按属性A进行划分，则A对D划分的期望信息为：</p>
<ol>
<li>信息增益：<img src="../img/Center-16704020088948.png" alt="img" style="zoom:50%;" /></li>
</ol>
<h3 id="5-2-6-Random-Forest"><a href="#5-2-6-Random-Forest" class="headerlink" title="5.2.6 Random Forest"></a>5.2.6 Random Forest</h3><p>​        随机森林是一种以决策树为基分类器的集成算法，通过组合多棵独立的决策树后根据投票或取均值的方式得到最终预测结果的机器学习方法，往往比单棵树具有更高的准确率和更强的稳定性。</p>
<p>​        随机森林相比于决策树拥有出色的性能主要取决于随机抽取样本和特征和集成算法，前者让它具有更稳定的抗过拟合能力，后者让它有更高的准确率。</p>
<h2 id="5-3-Naive-Bayes-classifier"><a href="#5-3-Naive-Bayes-classifier" class="headerlink" title="5.3 Naive Bayes classifier"></a>5.3 Naive Bayes classifier</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TOMOCAT/article/details/82934726">(36条消息) [DataAnalysis]贝叶斯分类器_TOMOCAT的博客-CSDN博客_corrplot</a></p>
<h3 id="5-3-1-条件概率："><a href="#5-3-1-条件概率：" class="headerlink" title="5.3.1 条件概率："></a>5.3.1 条件概率：</h3><script type="math/tex; mode=display">
P(A|B)=\frac{P(A\cap B)}{P(B)};P(B|A)=\frac{P(A\cap B)}{P(A)}</script><p>$P(A|B): $ 事件A在事件B发生的条件下发生的概率。条件概率表示为$P(A|B)$</p>
<h3 id="5-3-2-贝叶斯定理："><a href="#5-3-2-贝叶斯定理：" class="headerlink" title="5.3.2 贝叶斯定理："></a>5.3.2 贝叶斯定理：</h3><p>对于给出的待分类项（即特征属性的集合），求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。</p>
<script type="math/tex; mode=display">
P(A|B) \Longrightarrow P(B|A) = \frac{P(A|B)P(B)}{P(A)} \Longrightarrow P(B|A)</script><h3 id="5-3-3-朴素贝叶斯分类器："><a href="#5-3-3-朴素贝叶斯分类器：" class="headerlink" title="5.3.3 朴素贝叶斯分类器："></a>5.3.3 朴素贝叶斯分类器：</h3><ul>
<li><p>将每个属性和类标签视为随机变量</p>
</li>
<li><p>给出一个带有属性$（A_1, A_2, …, A_n）$的记录</p>
<ul>
<li><p>Goal: 预测类别$C$</p>
</li>
<li><p>寻找一个可以使得$P(C|A_1,A_2,…,A_n)$最大化的$C$值</p>
</li>
<li><script type="math/tex; mode=display">
P(C|A_1,A_2,...,A_n) = \frac{P(A_1,A_2,...,A_n|C)P(C)}{P(A_1,A_2,...,A_n)}</script></li>
<li><p>设属性$A_i$之间相互独立，便有</p>
<script type="math/tex; mode=display">
P(A_1, A_2, . . . , A_n|C_j) = \prod^{n}_iP(A_i|C_j)</script></li>
<li><p>而独立的$P(A_i|C_j)$是可估计的</p>
</li>
<li><p>则最大化$P(C|A_1,A_2,…,A_n)$等价于最大化$P(A_1,A_2,…,A_n|C)P(C)$，进一步等价于$P(C)\prod^{n}_iP(A_i|C)$</p>
<ul>
<li><p>若某个$i$所对应的条件概率为0，则根据上式整个表达式将为0</p>
</li>
<li><p>原始概率为</p>
<script type="math/tex; mode=display">
P(A_i|C) = \frac{N_{iC}}{N_C}</script></li>
<li><p>应用Laplace Smoothing：</p>
<script type="math/tex; mode=display">
P(A_i|C) = \frac{N_{iC}+a}{N_C+a\times(\#A_i)}</script><p>其中(#$A_i$)是$A_i$可能属于的总类数、$α&gt;0$是一个参数。为了简单起见，我们将始终设定$α=1$</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-4-Artificial-Neural-Networks-ANN’s"><a href="#5-4-Artificial-Neural-Networks-ANN’s" class="headerlink" title="5.4 Artificial Neural Networks (ANN’s)"></a>5.4 Artificial Neural Networks (ANN’s)</h2><p><img src="../img/image-20221203115345413.png" alt="image-20221203115345413" style="zoom:50%;" /></p>
<ul>
<li><p>$Z_i = σ(α_i + β_i^T X), i = 1,2,3$</p>
</li>
<li><p>$X = (X_1,X_2,X_3,X_4)^T$</p>
</li>
<li><p>$σ$：sigmoid函数，通常取$σ(x)=\frac{1}{1+e^{-x}}$</p>
</li>
<li><p>$σ$：激活函数（还有其他流行的激活函数）：</p>
<ul>
<li>如ReLU ： $σ(x) = max\{0, x\}$</li>
<li>$Y_i = σ(γ_i + δ_i^TZ), i = 1,2$.        $z=(z_1, z_2, z_3)$</li>
<li>本质上是一个优化问题。将$Y_i$’s适合于数据</li>
<li>但不是凸优化问题，因此并不能找到全局最优值</li>
<li>由于有多层隐藏层；因此容易造成过拟合</li>
</ul>
<h3 id="5-4-1-The-empirical-risk-function"><a href="#5-4-1-The-empirical-risk-function" class="headerlink" title="5.4.1 The empirical risk function"></a>5.4.1 The empirical risk function</h3><script type="math/tex; mode=display">
l(W_1, b_1, W_2, b_2) = \frac{1}{m}\sum^{m}_{j=1}V(Y^j, Y(X^j; W_1, b_1, W_2, b_2))</script><p>其中，函数$V$是衡量$Y^j$和$Y(X^j;W_1,b_1,W_2,b_2)$之间 “距离 “的损失函数。</p>
<p>For example, if $\alpha = \begin{pmatrix} \alpha_1\\\alpha_2\end{pmatrix}\$ and $\beta = \begin{pmatrix} \beta_1\\\beta_2\end{pmatrix}\$ ，可以应用如下损失函数</p>
</li>
</ul>
<p><img src="../img/image-20221203122616849.png" alt="image-20221203122616849" style="zoom:50%;" /></p>
<ul>
<li>通过最小化$l(W_1^<em>,b_1^</em>,W_2^<em>,b_2^</em>)$的最优参数<script type="math/tex; mode=display">
(W_1^*,b_1^*,W_2^*,b_2^*) = argmin l(W_1,b_1,W_2,b_2)</script></li>
</ul>
<p>通常情况下，最小化问题是通过梯度下降法解决的</p>
<h3 id="5-4-2-The-Backpropagation-Algorithm"><a href="#5-4-2-The-Backpropagation-Algorithm" class="headerlink" title="5.4.2 The Backpropagation Algorithm"></a>5.4.2 The Backpropagation Algorithm</h3><ul>
<li><p>现存问题：给定一个多元函数$f(x)\ with\ x\in\R^p $，求梯度$D_xf(x)$</p>
</li>
<li><p>Motivation：利用梯度下降法（gradient descent algorithm）最小化经验损失函数（empirical loss function），</p>
<script type="math/tex; mode=display">
f(x)=l(W_1,b_1,W_2,b_2),\\
x = (W_1^1,W_1^2,W_1^3,W_1^4,b_1,W_2^1,W_2^2,b_2^1,b_2^2) \in \R^9</script></li>
</ul>
<h2 id="5-5-Support-Vector-Machines"><a href="#5-5-Support-Vector-Machines" class="headerlink" title="5.5 Support Vector Machines"></a>5.5 Support Vector Machines</h2><p><a href="file:///C:/Users/NOID_/AppData/Local/Temp/MicrosoftEdgeDownloads/a8d49d85-2776-4a44-94c3-f942c2cb56e1/Intro2SVM.pdf">Intro2SVM.pdf</a></p>
<h3 id="5-5-1-Contour-lines-and-hyperplanes-of-linear-functions"><a href="#5-5-1-Contour-lines-and-hyperplanes-of-linear-functions" class="headerlink" title="5.5.1 Contour lines and hyperplanes of linear functions"></a>5.5.1 Contour lines and hyperplanes of linear functions</h3><p>通常将函数$f(x)=X^T\beta+\beta_0$称之为线性方程</p>
<p>For example：设$x = (x_1,x_2)^T$,$\beta = (\beta_1,\beta_2)^T$,则：</p>
<script type="math/tex; mode=display">
f(x)=x^T+\beta_0=\beta_1x_1+\beta_2x_2+\beta_0</script><ul>
<li>超平面：<ul>
<li>每个超平面都可以表示为一个值为零的线性函数的轮廓</li>
</ul>
</li>
<li>margin：</li>
<li>support vector：</li>
</ul>
<h3 id="5-5-2-Support-Vector-Machine"><a href="#5-5-2-Support-Vector-Machine" class="headerlink" title="5.5.2 Support Vector Machine"></a>5.5.2 Support Vector Machine</h3><p>上述问题可以转化为：</p>
<script type="math/tex; mode=display">
min\abs\beta\abs\,\\ subject\ to\ y_i(x_i^T\beta+\beta_0)\geqslant1,i=1,2,...,m</script><p>目标函数为凸函数，限制集也为凸函数，在大多数实际情况下，点集也不是线性可分离的。</p>
<p>则通常的SVM可定义为：</p>
<p><img src="C:\Users\NOID_\AppData\Roaming\Typora\typora-user-images\image-20221203210908752.png" alt="image-20221203210908752" style="zoom:50%;" /></p>
<p>$\phi_h(t)=max\{1-t,0\}$被叫做边缘损失函数（hinge loss function）</p>
<h3 id="5-5-3-Kernel-SVM"><a href="#5-5-3-Kernel-SVM" class="headerlink" title="5.5.3 Kernel SVM"></a>5.5.3 Kernel SVM</h3><p><img src="../img/image-20221203211159157.png" alt="image-20221203211159157" style="zoom:50%;" /></p>
<h2 id="5-6-Logistic-Regressin"><a href="#5-6-Logistic-Regressin" class="headerlink" title="5.6 Logistic Regressin"></a>5.6 Logistic Regressin</h2><p>可以用于<strong>多元</strong>和<strong>二元分类</strong>问题</p>
<ul>
<li><p>二元数据（Binary data）</p>
<p><img src="../img/image-20221203212020766.png" alt="image-20221203212020766" style="zoom:50%;" /></p>
</li>
</ul>
<p>$\phi(t) = \frac{e^t}{1+e^t}$   (Sigmoid function)</p>
<h3 id="5-6-1-Logistic-Regression"><a href="#5-6-1-Logistic-Regression" class="headerlink" title="5.6.1 Logistic Regression"></a>5.6.1 Logistic Regression</h3><ul>
<li><p>对数据进行二分类：$\{(x_i,y_i)\}^m_{i=1}$</p>
</li>
<li><p>$x_i\in\R^p$</p>
</li>
<li><p>$y_i\in\{-1,1\}$</p>
</li>
<li><p>逻辑回归算法+正则化参数定义如下：</p>
<p><img src="../img/image-20221203223605266.png" alt="image-20221203223605266" style="zoom:50%;" /></p>
</li>
<li><p>预测函数$f<em>(x)$为$x^T\beta^</em>$内积的指示函数</p>
<p><img src="../img/image-20221203223737416.png" alt="image-20221203223737416" style="zoom:50%;" /></p>
</li>
<li><p>设：</p>
<p><img src="../img/image-20221203223837335.png" alt="image-20221203223837335" style="zoom:50%;" /></p>
<p>则逻辑回归问题转化为最小化$\xi(\beta)+\lambda||\beta||^2$,该问题为凸优化</p>
</li>
<li><p>利用Sigmoid函数$\phi(t)$ rewrite $\xi(\beta)$</p>
<p><img src="../img/image-20221203225051631.png" alt="image-20221203225051631" style="zoom:50%;" /></p>
</li>
<li><p><img src="../img/image-20221203225111101-167040203970210.png" alt="image-20221203225111101" style="zoom:50%;" /></p>
</li>
<li><p>若设$\lambda=0$，则逻辑回归整体会过拟合</p>
</li>
<li><p>若数据为Separable，则$\xi(\beta)$ 可能难以取得最小值</p>
<ul>
<li>若$y_ix_i^T\beta&gt;0$，则 $\xi(\beta)$没有最小值</li>
<li><strong>Proof:</strong> 若$\beta^<em>$为最小值，则 $\xi(2\beta^</em>)&lt;\xi(\beta^*)$</li>
</ul>
</li>
<li><p><img src="../img/image-20221203232434814-167040204451511.png" alt="image-20221203232434814" style="zoom:50%;" /></p>
</li>
<li><p><img src="../img/image-20221203232457480.png" alt="image-20221203232457480" style="zoom:50%;" /></p>
</li>
</ul>
<p><img src="../img/image-20221203232705459.png" alt="image-20221203232705459" style="zoom:50%;" /></p>
<p><img src="../img/image-20221203232719841-167040205072512.png" alt="image-20221203232719841" style="zoom:50%;" /></p>
<p><img src="D:\Personal Blog\Blog Content\source\_posts\pic\image-20221203232742134.png" alt="image-20221203232742134" style="zoom:50%;" /></p>
<h2 id="5-7-Evaluating-the-Performance-of-Classifiers"><a href="#5-7-Evaluating-the-Performance-of-Classifiers" class="headerlink" title="5.7 Evaluating the Performance of Classifiers"></a>5.7 Evaluating the Performance of Classifiers</h2><h3 id="5-7-1-Score-based-classifier"><a href="#5-7-1-Score-based-classifier" class="headerlink" title="5.7.1 Score-based classifier"></a>5.7.1 Score-based classifier</h3><p><img src="../img/image-20221205094941810.png" alt="image-20221205094941810" style="zoom: 33%;" /></p>
<p><img src="../img/image-20221203233510289.png" alt="image-20221203233510289" style="zoom:50%;" /></p>
<h3 id="5-7-2-ROC-Curve"><a href="#5-7-2-ROC-Curve" class="headerlink" title="5.7.2 ROC Curve"></a>5.7.2 ROC Curve</h3><ul>
<li><p>对于$λ=-∞$，分类器预测一切为正</p>
<ul>
<li>根据前面的定义，$TPR = TPR(λ) = 1，而FPR = FPR(λ) = 1$（无用的预测器）</li>
</ul>
</li>
<li><p>对于$λ = ∞$，分类器预测一切为负</p>
</li>
<li>那么$T P R = T P R(λ) = 0，F P R = F P R(λ) = 0$（无用的预测器）</li>
<li>我们看到，当$λ从∞变为-∞时，F P R(λ)和T P R(λ)$都会增加</li>
<li>把假阳率$（FPR）当x轴，真阳率（TPR）当y轴$画一个二维平面直角坐标系。然后不断调整检测方法（或机器学习中的分类器）的阈值，即最终得分高于某个值就是阳性，反之就是阴性，得到不同的真阳率和假阳率数值，然后描点。就可以得到一条ROC曲线。<br>需要注意的是，ROC曲线必定起于$（0，0），止于（1，1）$。</li>
<li>因为，当全都判断为阴性(-)时，就是$（0，0）$；全部判断为阳性(+)时就是$（1，1）$。这两点间斜率为1的线段表示随机分类器（对真实的正负样本没有区分能力）。所以一般分类器需要在这条线上方。</li>
</ul>
<h4 id="5-7-2-1-AUC"><a href="#5-7-2-1-AUC" class="headerlink" title="5.7.2.1 AUC"></a>5.7.2.1 AUC</h4><ul>
<li>AUC被定义为ROC曲线下的面积。AUC的得分范围为[0，1]</li>
<li>AUC可以用来评估一个分类器的性能</li>
<li>AUC socre接近1表示分类效果较好</li>
<li>AUC接近0表示分类效果较好，但分类方法应当相反</li>
<li>AUC接近0.5表示分类效果较差。特别当$AUC≈0.5$意味着该分类器的性能几乎与随机猜测相同<ul>
<li>(Random Guess 也是一个分类器，但是是最差的分类器)</li>
</ul>
</li>
</ul>
<h1 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h1><h1 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h1><h2 id="7-1-Dimension-Reduction"><a href="#7-1-Dimension-Reduction" class="headerlink" title="7.1 Dimension Reduction"></a>7.1 Dimension Reduction</h2><h3 id="7-1-1-Principal-Component-Analysis-PCA"><a href="#7-1-1-Principal-Component-Analysis-PCA" class="headerlink" title="7.1.1 Principal Component Analysis (PCA)"></a>7.1.1 Principal Component Analysis (PCA)</h3><p><strong>Step 1:</strong> data normalization</p>
<p><strong>Step 2:</strong> singular value decomposition (SVD)</p>
<p><strong>Step 3:</strong> linear transform to achieve dimension reduction</p>
<p><img src="../img/image-20221206100035668.png" alt="image-20221206100035668" style="zoom:50%;" /></p>
<h2 id="7-2-Cluster-Analysis"><a href="#7-2-Cluster-Analysis" class="headerlink" title="7.2 Cluster Analysis"></a>7.2 Cluster Analysis</h2><h3 id="7-2-1-K-means-Clustering"><a href="#7-2-1-K-means-Clustering" class="headerlink" title="7.2.1 K-means Clustering"></a>7.2.1 K-means Clustering</h3><p>Step1：选择K个点作为初始中心点<br>Step2：通过将所有的点分配给最接近的中心点形成K个集群。<br>Step3：重新计算每个簇的中心点。如果所有计算出来的中心点与前面Step2的结果相同，则停止，否则重新执行Step2。</p>
<h4 id="7-2-1-1-Choosing-the-right-K"><a href="#7-2-1-1-Choosing-the-right-K" class="headerlink" title="7.2.1.1 Choosing the right K"></a>7.2.1.1 Choosing the right K</h4><ul>
<li>WCSS (<strong>Within Cluster Sum of Squares</strong>)： 评估中心点K的方式</li>
</ul>
<p><img src="../img/image-20221206103838184.png" alt="image-20221206103838184" style="zoom:33%;" /></p>
<ul>
<li><p>The Elbow Method：利用The Elbow Method根据WCSS选择最佳K值</p>
<p>结果显示，在3次之后，WCSS没有明显下降，所以3次是最好的。</p>
<p><img src="../img/image-20221206110430866.png" alt="image-20221206110430866" style="zoom:50%;" /></p>
</li>
<li><p>Shortcomings</p>
<ul>
<li><p>多次迭代：有帮助，但概率不在你这边；</p>
</li>
<li><p>可能产生空聚类。例如，我们可以重新放置空簇的中心点，以便使下面的SSE最小化；</p>
<p><img src="../img/image-20221206112123894.png" alt="image-20221206112123894" style="zoom:50%;" /></p>
</li>
<li><p>当点分布在流形上但使用环境距离时，可能会得到不好的结果；</p>
<p><img src="../img/image-20221206112107419.png" alt="image-20221206112107419" style="zoom:50%;" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="7-2-2-Hierarchical-Clustering"><a href="#7-2-2-Hierarchical-Clustering" class="headerlink" title="7.2.2 Hierarchical Clustering"></a>7.2.2 Hierarchical Clustering</h3><h4 id="7-2-2-1-Strength-of-Hierarchical-Clustering"><a href="#7-2-2-1-Strength-of-Hierarchical-Clustering" class="headerlink" title="7.2.2.1 Strength of Hierarchical Clustering"></a>7.2.2.1 Strength of Hierarchical Clustering</h4><ul>
<li><p>不需要假设聚类数量，但需要在特定的层次上切割以形成聚类。</p>
</li>
<li><p>树状图很可能对应于有意义的分类法</p>
</li>
<li>Hierarchical Clustering是一种多层次的聚类算法：<ul>
<li>计算接近度矩阵</li>
<li>让每个数据点单独成为一个集群</li>
<li><strong>Repeat：</strong><ul>
<li>合并最接近的两个集群</li>
<li>更新接近度矩阵（proximity matrix）</li>
</ul>
</li>
<li><strong>Until</strong>：只剩下一个单一的集群</li>
</ul>
</li>
</ul>
<h2 id="7-3-Gaussian-Mixture-Model-Clustering-Using-EM-Algorithm"><a href="#7-3-Gaussian-Mixture-Model-Clustering-Using-EM-Algorithm" class="headerlink" title="7.3 Gaussian Mixture Model Clustering Using EM Algorithm"></a>7.3 Gaussian Mixture Model Clustering Using EM Algorithm</h2><h3 id="7-3-1-Maximum-likelihood-estimation-MLE"><a href="#7-3-1-Maximum-likelihood-estimation-MLE" class="headerlink" title="7.3.1 Maximum likelihood estimation (MLE)"></a>7.3.1 Maximum likelihood estimation (MLE)</h3><h4 id="7-3-1-1-Likelihood-Function"><a href="#7-3-1-1-Likelihood-Function" class="headerlink" title="7.3.1.1 Likelihood Function"></a>7.3.1.1 Likelihood Function</h4><p>​    令$X_1，X_2，…，X_n$是随机分布的样本，其特征为 $p(x|θ)$</p>
<ul>
<li><p>其中$θ$是一个未知参数;</p>
</li>
<li><p>$x_1, … … , x_n$是观测值</p>
</li>
<li><p>则似然函数的定义为：</p>
<p><img src="../img/image-20221206162104316.png" alt="image-20221206162104316" style="zoom:50%;" /></p>
</li>
</ul>
<h4 id="7-3-1-2-Log-likelihood-Function"><a href="#7-3-1-2-Log-likelihood-Function" class="headerlink" title="7.3.1.2 Log-likelihood Function"></a>7.3.1.2 Log-likelihood Function</h4><p><img src="../img/image-20221206162151305.png" alt="image-20221206162151305" style="zoom:50%;" /></p>
<ul>
<li><p>如果参数$θ使L(θ)$最大化，它也会使$l(θ)$最大化；</p>
</li>
<li><p>密度函数$p(x|θ)$是由参数$θ$决定的；在满足条件$θ$的情况下，不应该被当作条件密度函数(conditional density function) ；</p>
</li>
<li><p>参数$θ$不是随机的；</p>
</li>
</ul>
<h4 id="7-3-1-3-maximum-likelihood-estimator-MLE"><a href="#7-3-1-3-maximum-likelihood-estimator-MLE" class="headerlink" title="7.3.1.3 maximum likelihood estimator, MLE"></a>7.3.1.3 maximum likelihood estimator, <strong>MLE</strong></h4><p>最大似然估计器（MLE）$\hatθ_{mle} = \hatθ_{mle}(X_1, … , X_n)$被定义为是使似然函数 $L(θ)$最大化的参数（或者等同于使对数似然函数 $l(θ)$最大化）</p>
<p><img src="../img/image-20221206170004672.png" alt="image-20221206170004672" style="zoom:50%;" /></p>
<p><strong>Remark</strong></p>
<p>$\hatθ$是样本 $\hatθ(X_1，…，X_n)$的一个函数，因此它是一个随机变量</p>
<p>根据我们之前的定义，MLE $\hatθ$是一个统计量，也被称为点估计器。</p>
<p><strong>Remark</strong></p>
<p>如果未知分布$p$是由超过一个的参数指定的。$ p = p(x|θ_1, . . , θ_k)$，那么似然函数定义为</p>
<p><img src="../img/image-20221206172155537.png" alt="image-20221206172155537" style="zoom:50%;" /></p>
<p>而对数似然函数被定义为$l(θ_1, . . , θ_k) = logL(θ_1, . . , θ_k)$。MLE是使$L或l$最大化的向量$（\hatθ_1, …, \hatθ_k）$。</p>
<h5 id="How-to-find-the-MLE"><a href="#How-to-find-the-MLE" class="headerlink" title="How to find the MLE"></a>How to find the MLE</h5><p>求函数$L(θ)$的最大值的通常需要以下两个步骤：</p>
<p>Step1：通过下式求$θ$</p>
<script type="math/tex; mode=display">
\frac{d}{dθ}L(θ) = 0</script><p>Step2：验证这个$θ$值是最大值的，方法是检查对这个θ值符合：</p>
<script type="math/tex; mode=display">
\frac{d^2}{dθ^2}L(θ) \leq 0</script><p><strong>Remark</strong></p>
<ul>
<li>方程（1）的解不一定是唯一的</li>
<li>严格地说，上述两个步骤只能找到局部最大值，而MLE应当是全局最大值</li>
<li>在方程（1）和（2）中，函数$L(θ)$可以改为$l(θ)=logL(θ)$，因为对数函数是严格单调递增</li>
</ul>
<h3 id="7-3-2-Numerical-Calculation"><a href="#7-3-2-Numerical-Calculation" class="headerlink" title="7.3.2 Numerical Calculation"></a>7.3.2 Numerical Calculation</h3><h3 id="7-3-3-Conditional-Probability"><a href="#7-3-3-Conditional-Probability" class="headerlink" title="7.3.3 Conditional Probability"></a>7.3.3 Conditional Probability</h3><h3 id="7-3-4-The-EM-Algorithm"><a href="#7-3-4-The-EM-Algorithm" class="headerlink" title="7.3.4 The EM Algorithm"></a>7.3.4 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78311644">The EM Algorithm</a></h3><p>EM 算法，全称 Expectation Maximization Algorithm。期望最大算法是一种迭代算法，用于含有隐变量（Hidden Variable）的概率参数模型的最大似然估计或极大后验概率估计。</p>
<p>EM 算法的核心思想非常简单，分为两步：Expection-Step 和 Maximization-Step。</p>
<ul>
<li><p>E-Step 主要通过观察数据和现有模型来估计参数，然后<strong>用这个估计的参数值来计算似然函数的期望值</strong>；</p>
</li>
<li><p>M-Step 是<strong>寻找似然函数最大化时对应的参数</strong>。由于算法会保证在每次迭代之后似然函数都会增加，所以函数最终会收敛。</p>
<h4 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h4><script type="math/tex; mode=display">
θ^{new} = arg\max_{θ}Q(θ, θ^{old}).</script><h5 id="Jensen’s-inequality"><a href="#Jensen’s-inequality" class="headerlink" title="Jensen’s inequality"></a>Jensen’s inequality</h5><ul>
<li><p>如果$ f $是凹函数，$X$ 是随机变量，则 $E[f(X)]≤f(E[X])$ </p>
</li>
<li><p>当$ f$ 严格是凹函数是，则 $E[f(X)]&lt;f(E[X])$ ，凸函数反之</p>
</li>
<li><p>当 $X=E[X]$ 时，即为常数时等式成立</p>
</li>
</ul>
<p><strong>==Example==</strong></p>
<p>Suppose that 197 animals$ (Y)$ are distributed into four categories as follows</p>
<script type="math/tex; mode=display">
Y = (y_1, y_2, y_3, y_4) = (125,18,20,34),</script></li>
</ul>
<p>  with cell probabilities</p>
<script type="math/tex; mode=display">
  \begin{pmatrix} \frac{1}{2}+\frac{θ}{4},\frac{1}{4}(1 − θ),\frac{1}{4}(1 − θ),\frac{θ}{4}\end{pmatrix}</script><p>  We augment the observed data by splitt in the first cell into two cells with probabilities $\frac{1}{2}$ and $\frac{θ}{4}$. The augmented data are given by</p>
<script type="math/tex; mode=display">
  (x_1, x_2, x_3, x_4, x_5)</script><p>  such that $ x_1 + x_2 = y_1, x_3 = y_2, x_4 = y_3, x_5 = y_4.$</p>
<p>  We will infer <em>θ</em> from the data.</p>
<ul>
<li><p><strong>Method 2 (EM Algorithm)</strong></p>
<ul>
<li>E-Step</li>
</ul>
</li>
</ul>
<ul>
<li>M-Step</li>
</ul>
<h2 id="7-4-Other-clustering-methods"><a href="#7-4-Other-clustering-methods" class="headerlink" title="7.4 Other clustering methods"></a>7.4 Other clustering methods</h2><h3 id="7-4-1-Prototype-based-Clustering"><a href="#7-4-1-Prototype-based-Clustering" class="headerlink" title="7.4.1 Prototype-based Clustering"></a>7.4.1 Prototype-based Clustering</h3><h1 id="Chapter-8"><a href="#Chapter-8" class="headerlink" title="Chapter 8"></a>Chapter 8</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Ephemeral</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/02/Statistical-Data-Mining/">http://example.com/2022/12/02/Statistical-Data-Mining/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/28/Machine-Learning/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Machine Learning</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ephemeral</div><div class="author-info__description">Live Fast, Die Young, Be Wild, Have Fun</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Intro"><span class="toc-number">1.</span> <span class="toc-text">Intro</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-Derivatives"><span class="toc-number">1.1.</span> <span class="toc-text">0.1. Derivatives</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-Taylor"><span class="toc-number">1.2.</span> <span class="toc-text">0.2. Taylor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1"><span class="toc-number">2.</span> <span class="toc-text">Chapter 1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2"><span class="toc-number">3.</span> <span class="toc-text">Chapter 2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3"><span class="toc-number">4.</span> <span class="toc-text">Chapter 3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4"><span class="toc-number">5.</span> <span class="toc-text">Chapter 4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Singular-Value-Decomposition"><span class="toc-number">5.1.</span> <span class="toc-text">4.1. Singular Value Decomposition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Least-Squares"><span class="toc-number">5.2.</span> <span class="toc-text">4.2. Least Squares</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Ridge-Regression"><span class="toc-number">5.3.</span> <span class="toc-text">4.3. Ridge Regression</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Lasso"><span class="toc-number">5.4.</span> <span class="toc-text">4.4. Lasso</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5"><span class="toc-number">6.</span> <span class="toc-text">Chapter 5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Classification"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 Classification</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Decision-Tree"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 Decision Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E7%BB%93%E7%82%B9%EF%BC%9A"><span class="toc-number">6.2.1.</span> <span class="toc-text">5.2.1 结点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-Hunt-Algorithm%EF%BC%9A"><span class="toc-number">6.2.2.</span> <span class="toc-text">5.2.2 Hunt Algorithm：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E8%A1%A8%E7%A4%BA%E5%B1%9E%E6%80%A7%E6%B5%8B%E8%AF%95%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">5.2.3 表示属性测试条件的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E5%88%92%E5%88%86%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">6.2.4.</span> <span class="toc-text">5.2.4 选择最佳划分的度量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-1-Measures-of-Impurity"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">5.2.4.1 Measures of Impurity</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-Model-over-fitting"><span class="toc-number">6.2.5.</span> <span class="toc-text">5.2.5 Model over-fitting</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-1-%E8%A7%A3%E5%86%B3%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">5.2.5.1 解决过拟合的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-2-ID3-algorithm"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">5.2.5.2 ID3 algorithm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6-Random-Forest"><span class="toc-number">6.2.6.</span> <span class="toc-text">5.2.6 Random Forest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Naive-Bayes-classifier"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 Naive Bayes classifier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%EF%BC%9A"><span class="toc-number">6.3.1.</span> <span class="toc-text">5.3.1 条件概率：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%9A"><span class="toc-number">6.3.2.</span> <span class="toc-text">5.3.2 贝叶斯定理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%9A"><span class="toc-number">6.3.3.</span> <span class="toc-text">5.3.3 朴素贝叶斯分类器：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Artificial-Neural-Networks-ANN%E2%80%99s"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 Artificial Neural Networks (ANN’s)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-The-empirical-risk-function"><span class="toc-number">6.4.1.</span> <span class="toc-text">5.4.1 The empirical risk function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-The-Backpropagation-Algorithm"><span class="toc-number">6.4.2.</span> <span class="toc-text">5.4.2 The Backpropagation Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Support-Vector-Machines"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 Support Vector Machines</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-Contour-lines-and-hyperplanes-of-linear-functions"><span class="toc-number">6.5.1.</span> <span class="toc-text">5.5.1 Contour lines and hyperplanes of linear functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-Support-Vector-Machine"><span class="toc-number">6.5.2.</span> <span class="toc-text">5.5.2 Support Vector Machine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3-Kernel-SVM"><span class="toc-number">6.5.3.</span> <span class="toc-text">5.5.3 Kernel SVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Logistic-Regressin"><span class="toc-number">6.6.</span> <span class="toc-text">5.6 Logistic Regressin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-1-Logistic-Regression"><span class="toc-number">6.6.1.</span> <span class="toc-text">5.6.1 Logistic Regression</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-Evaluating-the-Performance-of-Classifiers"><span class="toc-number">6.7.</span> <span class="toc-text">5.7 Evaluating the Performance of Classifiers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-1-Score-based-classifier"><span class="toc-number">6.7.1.</span> <span class="toc-text">5.7.1 Score-based classifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-2-ROC-Curve"><span class="toc-number">6.7.2.</span> <span class="toc-text">5.7.2 ROC Curve</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-1-AUC"><span class="toc-number">6.7.2.1.</span> <span class="toc-text">5.7.2.1 AUC</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6"><span class="toc-number">7.</span> <span class="toc-text">Chapter 6</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7"><span class="toc-number">8.</span> <span class="toc-text">Chapter 7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Dimension-Reduction"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 Dimension Reduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-Principal-Component-Analysis-PCA"><span class="toc-number">8.1.1.</span> <span class="toc-text">7.1.1 Principal Component Analysis (PCA)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Cluster-Analysis"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 Cluster Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-K-means-Clustering"><span class="toc-number">8.2.1.</span> <span class="toc-text">7.2.1 K-means Clustering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-1-Choosing-the-right-K"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">7.2.1.1 Choosing the right K</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-Hierarchical-Clustering"><span class="toc-number">8.2.2.</span> <span class="toc-text">7.2.2 Hierarchical Clustering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-1-Strength-of-Hierarchical-Clustering"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">7.2.2.1 Strength of Hierarchical Clustering</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Gaussian-Mixture-Model-Clustering-Using-EM-Algorithm"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 Gaussian Mixture Model Clustering Using EM Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-Maximum-likelihood-estimation-MLE"><span class="toc-number">8.3.1.</span> <span class="toc-text">7.3.1 Maximum likelihood estimation (MLE)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-1-Likelihood-Function"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">7.3.1.1 Likelihood Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-2-Log-likelihood-Function"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">7.3.1.2 Log-likelihood Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-3-maximum-likelihood-estimator-MLE"><span class="toc-number">8.3.1.3.</span> <span class="toc-text">7.3.1.3 maximum likelihood estimator, MLE</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#How-to-find-the-MLE"><span class="toc-number">8.3.1.3.1.</span> <span class="toc-text">How to find the MLE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-Numerical-Calculation"><span class="toc-number">8.3.2.</span> <span class="toc-text">7.3.2 Numerical Calculation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-Conditional-Probability"><span class="toc-number">8.3.3.</span> <span class="toc-text">7.3.3 Conditional Probability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-The-EM-Algorithm"><span class="toc-number">8.3.4.</span> <span class="toc-text">7.3.4 The EM Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EM"><span class="toc-number">8.3.4.1.</span> <span class="toc-text">EM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Jensen%E2%80%99s-inequality"><span class="toc-number">8.3.4.1.1.</span> <span class="toc-text">Jensen’s inequality</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Other-clustering-methods"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 Other clustering methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-Prototype-based-Clustering"><span class="toc-number">8.4.1.</span> <span class="toc-text">7.4.1 Prototype-based Clustering</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-8"><span class="toc-number">9.</span> <span class="toc-text">Chapter 8</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/02/Statistical-Data-Mining/" title="statistical data mining"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="statistical data mining"/></a><div class="content"><a class="title" href="/2022/12/02/Statistical-Data-Mining/" title="statistical data mining">statistical data mining</a><time datetime="2022-12-02T07:20:21.000Z" title="Created 2022-12-02 15:20:21">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/28/Machine-Learning/" title="Machine Learning"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Machine Learning"/></a><div class="content"><a class="title" href="/2022/11/28/Machine-Learning/" title="Machine Learning">Machine Learning</a><time datetime="2022-11-28T12:12:51.000Z" title="Created 2022-11-28 20:12:51">2022-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/11/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Leetcode刷题笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode刷题笔记"/></a><div class="content"><a class="title" href="/2022/11/11/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="Leetcode刷题笔记">Leetcode刷题笔记</a><time datetime="2022-11-11T03:16:24.000Z" title="Created 2022-11-11 11:16:24">2022-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/25/Python-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="Python 基础语法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 基础语法"/></a><div class="content"><a class="title" href="/2022/10/25/Python-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" title="Python 基础语法">Python 基础语法</a><time datetime="2022-10-25T05:08:14.000Z" title="Created 2022-10-25 13:08:14">2022-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3/" title="特征分解"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="特征分解"/></a><div class="content"><a class="title" href="/2022/10/24/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3/" title="特征分解">特征分解</a><time datetime="2022-10-24T03:34:17.000Z" title="Created 2022-10-24 11:34:17">2022-10-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Ephemeral</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>